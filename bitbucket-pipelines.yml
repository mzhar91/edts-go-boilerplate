# Default variable need to set
# - DOCKER_IMAGE_NAME
# - MAVEN_USERNAME
# - MAVEN_PASSWORD
#
# Docker Hub
# - DOCKER_HUB_USERNAME
# - DOCKER_HUB_PASSWORD
#
# Docker GKE
# - GCLOUD_API_KEYFILE (DEPLOYMENTS)
# - GCLOUD_PROJECT_ID (DEPLOYMENTS)
# - GCLOUD_GKE_CLUSTER (DEPLOYMENTS)
# - GCLOUD_GCR_REPO_URL
# - GCLOUD_ZONE
# - K8S_SERVICE_NAME
# - K8S_NAMESPACE
definitions:
  steps:
    - step: &mvn-package-and-build-image
        name: Maven Package and Build Docker Image
        image: maven:3.8.5-openjdk-17-slim
        caches:
          - maven
          - docker
        services:
          - docker
        script:
          - mvn -s settings.xml -B clean package -Dmaven.test.skip=true
          - export DEFAULT_IMAGE_NAME=$DOCKER_IMAGE_NAME:$BITBUCKET_COMMIT
          - docker build -t $DEFAULT_IMAGE_NAME .
          - docker save --output docker.tar $DEFAULT_IMAGE_NAME
        artifacts:
          - docker.tar

    - step: &mvn-package-and-build-image-with-stackify
        name: Maven Package and Build Docker Image
        image: maven:3.8.5-openjdk-17-slim
        caches:
          - maven
          - docker
        services:
          - docker
        script:
          - mvn -s settings.xml -B clean package -Dmaven.test.skip=true
          - export DEFAULT_IMAGE_NAME=$DOCKER_IMAGE_NAME:$BITBUCKET_COMMIT
          - docker build --file Dockerfile-stackify -t $DEFAULT_IMAGE_NAME .
          - docker save --output docker.tar $DEFAULT_IMAGE_NAME
        artifacts:
          - docker.tar

    - step: &push-image-to-dockerhub
        name: Push Image to DockerHub
        clone:
          enabled: false
        caches:
          - docker
        services:
          - docker
        script:
          - export DEFAULT_IMAGE_NAME=$DOCKER_IMAGE_NAME:$BITBUCKET_COMMIT
          - export IMAGE_NAME=$DOCKER_HUB_USERNAME/$DOCKER_IMAGE_NAME:$BITBUCKET_COMMIT
          - docker load --input docker.tar
          - docker tag $DEFAULT_IMAGE_NAME $IMAGE_NAME
          - docker login --username $DOCKER_HUB_USERNAME --password $DOCKER_HUB_PASSWORD
          - echo $IMAGE_NAME
          - docker push $IMAGE_NAME

    - step: &push-and-deploy-gke-staging
        deployment: env-staging
        name: Push Image and Deploy to GKE
        clone:
          enabled: false
        image: google/cloud-sdk:latest
        caches:
          - docker
        services:
          - docker
        script:
          - export USE_GKE_GCLOUD_AUTH_PLUGIN=TRUE
          - export DEFAULT_IMAGE_NAME=$DOCKER_IMAGE_NAME:$BITBUCKET_COMMIT
          - export IMAGE_NAME=$GCLOUD_GCR_REPO_URL/$GCLOUD_PROJECT_ID/$ENV/$DOCKER_IMAGE_NAME:${BITBUCKET_COMMIT}
          - docker load --input docker.tar
          - docker tag $DEFAULT_IMAGE_NAME $IMAGE_NAME
          - echo $GCLOUD_API_KEYFILE > ~/.gcloud-api-key.json
          - gcloud auth activate-service-account --key-file ~/.gcloud-api-key.json
          - docker login -u _json_key --password-stdin https://$GCLOUD_GCR_REPO_URL < ~/.gcloud-api-key.json
          - docker push $IMAGE_NAME
          # DEPLOYMENT
          - gcloud container clusters get-credentials $GCLOUD_GKE_CLUSTER --zone=$GCLOUD_ZONE --project $GCLOUD_PROJECT_ID
          - kubectl -n $K8S_NAMESPACE set image deployment $K8S_SERVICE_NAME $K8S_SERVICE_NAME=$IMAGE_NAME

    - step: &push-and-deploy-gke-uat
        deployment: env-uat
        name: Push Image and Deploy to GKE
        clone:
          enabled: false
        image: google/cloud-sdk:latest
        caches:
          - docker
        services:
          - docker
        script:
          - export USE_GKE_GCLOUD_AUTH_PLUGIN=TRUE
          - export DEFAULT_IMAGE_NAME=$DOCKER_IMAGE_NAME:$BITBUCKET_COMMIT
          - export IMAGE_NAME=$GCLOUD_GCR_REPO_URL/$GCLOUD_PROJECT_ID/$ENV/$DOCKER_IMAGE_NAME:${BITBUCKET_COMMIT}
          - docker load --input docker.tar
          - docker tag $DEFAULT_IMAGE_NAME $IMAGE_NAME
          - echo $GCLOUD_API_KEYFILE > ~/.gcloud-api-key.json
          - gcloud auth activate-service-account --key-file ~/.gcloud-api-key.json
          - docker login -u _json_key --password-stdin https://$GCLOUD_GCR_REPO_URL < ~/.gcloud-api-key.json
          - docker push $IMAGE_NAME
          # DEPLOYMENT
          - gcloud container clusters get-credentials $GCLOUD_GKE_CLUSTER --zone=$GCLOUD_ZONE --project $GCLOUD_PROJECT_ID
          - kubectl -n $K8S_NAMESPACE set image deployment $K8S_SERVICE_NAME $K8S_SERVICE_NAME=$IMAGE_NAME

    - step: &push-and-deploy-gke-to
        deployment: env-to
        name: Push Image and Deploy to GKE
        clone:
          enabled: false
        image: google/cloud-sdk:latest
        caches:
          - docker
        services:
          - docker
        script:
          - export USE_GKE_GCLOUD_AUTH_PLUGIN=TRUE
          - export DEFAULT_IMAGE_NAME=$DOCKER_IMAGE_NAME:$BITBUCKET_COMMIT
          - export IMAGE_NAME=$GCLOUD_GCR_REPO_URL/$GCLOUD_PROJECT_ID/$ENV/$DOCKER_IMAGE_NAME:${BITBUCKET_COMMIT}
          - docker load --input docker.tar
          - docker tag $DEFAULT_IMAGE_NAME $IMAGE_NAME
          - echo $GCLOUD_API_KEYFILE > ~/.gcloud-api-key.json
          - gcloud auth activate-service-account --key-file ~/.gcloud-api-key.json
          - docker login -u _json_key --password-stdin https://$GCLOUD_GCR_REPO_URL < ~/.gcloud-api-key.json
          - docker push $IMAGE_NAME
          # DEPLOYMENT
          - gcloud container clusters get-credentials $GCLOUD_GKE_CLUSTER --zone=$GCLOUD_ZONE --project $GCLOUD_PROJECT_ID
          - kubectl -n $K8S_NAMESPACE set image deployment $K8S_SERVICE_NAME $K8S_SERVICE_NAME=$IMAGE_NAME

    - step: &push-and-deploy-gke-production
        deployment: env-production
        name: Push Image and Deploy to GKE
        clone:
          enabled: false
        image: google/cloud-sdk:latest
        caches:
          - docker
        services:
          - docker
        script:
          - export USE_GKE_GCLOUD_AUTH_PLUGIN=TRUE
          - export DEFAULT_IMAGE_NAME=$DOCKER_IMAGE_NAME:$BITBUCKET_COMMIT
          - export IMAGE_NAME=$GCLOUD_GCR_REPO_URL/$GCLOUD_PROJECT_ID/$ENV/$DOCKER_IMAGE_NAME:${BITBUCKET_COMMIT}
          - docker load --input docker.tar
          - docker tag $DEFAULT_IMAGE_NAME $IMAGE_NAME
          - echo $GCLOUD_API_KEYFILE > ~/.gcloud-api-key.json
          - gcloud auth activate-service-account --key-file ~/.gcloud-api-key.json
          - docker login -u _json_key --password-stdin https://$GCLOUD_GCR_REPO_URL < ~/.gcloud-api-key.json
          - docker push $IMAGE_NAME
          # DEPLOYMENT
          - gcloud container clusters get-credentials $GCLOUD_GKE_CLUSTER --zone=$GCLOUD_ZONE --project $GCLOUD_PROJECT_ID
          - kubectl -n $K8S_NAMESPACE set image deployment $K8S_SERVICE_NAME $K8S_SERVICE_NAME=$IMAGE_NAME
          
    - step: &push-and-deploy-staging
        deployment: env-staging
        name: Push Image and Deploy to AWS
        clone:
          enabled: false
        image: atlassian/pipelines-awscli
        caches:
          - docker
        services:
          - docker
        script:
          - export DEFAULT_IMAGE_NAME=$DOCKER_IMAGE_NAME:$BITBUCKET_COMMIT
          - export IMAGE_NAME=$AWS_ECR_REPOSITORY/$DOCKER_IMAGE_NAME:${BITBUCKET_COMMIT}
          - echo ${IMAGE_NAME}
          - docker load --input docker.tar
          - docker tag $DEFAULT_IMAGE_NAME $IMAGE_NAME
          - aws configure set aws_access_key_id "${AWS_ACCESS_KEY_ID}"
          - aws configure set aws_secret_access_key "${AWS_SECRET_ACCESS_KEY}"
          - eval $(aws ecr get-login --no-include-email --region $AWS_DEFAULT_REGION | sed 's;https://;;g')
          - docker push $IMAGE_NAME
          - pipe: atlassian/aws-eks-kubectl-run:1.3.1
            variables:
              AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID}
              AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY}
              AWS_DEFAULT_REGION: $AWS_DEFAULT_REGION
              CLUSTER_NAME: $EKS_CLUSTER_NAME
              IMAGE_NAME: $AWS_ECR_REPOSITORY:$BITBUCKET_COMMIT
              KUBECTL_COMMAND: '-n $K8S_NAMESPACE set image deployment $K8S_SERVICE_NAME $K8S_SERVICE_NAME=$IMAGE_NAME'
          
    - step: &push-and-deploy-uat
        deployment: env-uat
        name: Push Image and Deploy to AWS UAT
        clone:
          enabled: false
        image: atlassian/pipelines-awscli
        caches:
          - docker
        services:
          - docker
        script:
          - export DEFAULT_IMAGE_NAME=$DOCKER_IMAGE_NAME:$BITBUCKET_COMMIT
          - export IMAGE_NAME=$AWS_ECR_REPOSITORY/$DOCKER_IMAGE_NAME:${BITBUCKET_COMMIT}
          - echo ${IMAGE_NAME}
          - docker load --input docker.tar
          - docker tag $DEFAULT_IMAGE_NAME $IMAGE_NAME
          - aws configure set aws_access_key_id "${AWS_ACCESS_KEY_ID}"
          - aws configure set aws_secret_access_key "${AWS_SECRET_ACCESS_KEY}"
          - eval $(aws ecr get-login --no-include-email --region $AWS_DEFAULT_REGION | sed 's;https://;;g')
          - docker push $IMAGE_NAME
          - pipe: atlassian/aws-eks-kubectl-run:1.3.1
            variables:
              AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID}
              AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY}
              AWS_DEFAULT_REGION: $AWS_DEFAULT_REGION
              CLUSTER_NAME: $EKS_CLUSTER_NAME
              IMAGE_NAME: $AWS_ECR_REPOSITORY:$BITBUCKET_COMMIT
              KUBECTL_COMMAND: '-n $K8S_NAMESPACE set image deployment $K8S_SERVICE_NAME $K8S_SERVICE_NAME=$IMAGE_NAME'
          
    - step: &push-and-deploy-to
        deployment: env-to
        name: Push Image and Deploy to AWS TO/Prod
        clone:
          enabled: false
        image: atlassian/pipelines-awscli
        caches:
          - docker
        services:
          - docker
        script:
          - export DEFAULT_IMAGE_NAME=$DOCKER_IMAGE_NAME:$BITBUCKET_COMMIT
          - export IMAGE_NAME=$AWS_ECR_REPOSITORY/$DOCKER_IMAGE_NAME:${BITBUCKET_COMMIT}
          - echo ${IMAGE_NAME}
          - docker load --input docker.tar
          - docker tag $DEFAULT_IMAGE_NAME $IMAGE_NAME
          - aws configure set aws_access_key_id "${AWS_ACCESS_KEY_ID}"
          - aws configure set aws_secret_access_key "${AWS_SECRET_ACCESS_KEY}"
          - eval $(aws ecr get-login --no-include-email --region $AWS_DEFAULT_REGION | sed 's;https://;;g')
          - docker push $IMAGE_NAME
          - pipe: atlassian/aws-eks-kubectl-run:1.3.1
            variables:
              AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID}
              AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY}
              AWS_DEFAULT_REGION: $AWS_DEFAULT_REGION
              CLUSTER_NAME: $EKS_CLUSTER_NAME
              IMAGE_NAME: $AWS_ECR_REPOSITORY:$BITBUCKET_COMMIT
              KUBECTL_COMMAND: '-n $K8S_NAMESPACE set image deployment $K8S_SERVICE_NAME $K8S_SERVICE_NAME=$IMAGE_NAME'
          
    - step: &push-and-deploy-production
        deployment: env-production
        name: Push Image and Deploy to AWS TO/Prod
        clone:
          enabled: false
        image: atlassian/pipelines-awscli
        caches:
          - docker
        services:
          - docker
        script:
          - export DEFAULT_IMAGE_NAME=$DOCKER_IMAGE_NAME:$BITBUCKET_COMMIT
          - export IMAGE_NAME=$AWS_ECR_REPOSITORY/$DOCKER_IMAGE_NAME:${BITBUCKET_COMMIT}
          - echo ${IMAGE_NAME}
          - docker load --input docker.tar
          - docker tag $DEFAULT_IMAGE_NAME $IMAGE_NAME
          - aws configure set aws_access_key_id "${AWS_ACCESS_KEY_ID}"
          - aws configure set aws_secret_access_key "${AWS_SECRET_ACCESS_KEY}"
          - eval $(aws ecr get-login --no-include-email --region $AWS_DEFAULT_REGION | sed 's;https://;;g')
          - docker push $IMAGE_NAME
          - pipe: atlassian/aws-eks-kubectl-run:1.3.1
            variables:
              AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID}
              AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY}
              AWS_DEFAULT_REGION: $AWS_DEFAULT_REGION
              CLUSTER_NAME: $EKS_CLUSTER_NAME
              IMAGE_NAME: $AWS_ECR_REPOSITORY:$BITBUCKET_COMMIT
              KUBECTL_COMMAND: '-n $K8S_NAMESPACE set image deployment $K8S_SERVICE_NAME $K8S_SERVICE_NAME=$IMAGE_NAME'


pipelines:
  branches:
    staging:
      - step: *mvn-package-and-build-image
#      - step: *push-and-deploy-gke-staging
      - step: *push-and-deploy-staging
    uat:
      - step: *mvn-package-and-build-image
#      - step: *push-and-deploy-gke-uat
      - step: *push-and-deploy-uat
    to:
      - step: *mvn-package-and-build-image-with-stackify
      - step: *push-and-deploy-to
    master:
      - step: *mvn-package-and-build-image
      - step: *push-and-deploy-production
#    deploy-docker-hub:
#      - step: *mvn-package-and-build-image
#      - step: *push-image-to-dockerhub